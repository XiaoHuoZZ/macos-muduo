# socket的一些设置

# SO_REUSEADDR

如果在一个socket绑定到某一地址和端口之前设置了其`SO_REUSEADDR`的属性，那么除非本socket与产生了尝试与另一个socket绑定到完全相同的源地址和源端口组合的冲突，否则的话这个socket就可以成功的绑定这个地址端口对。

如果不用`SO_REUSEADDR`的话，如果我们将`socketA`绑定到`0.0.0.0:21`，那么任何将本机其他socket绑定到端口`21`的举动（如绑定到`192.168.1.1:21`）都会导致`EADDRINUSE`错误。因为`0.0.0.0`是一个通配符IP地址，意味着任意一个IP地址，所以任何其他本机上的IP地址都被系统认已被占用。

另外如果我们在新的socket上设置了`SO_REUSEADDR`选项，如果此时有另一个socket绑定在当前的地址端口对且处于`TIME_WAIT`阶段，那么这个已存在的绑定关系将会被忽略。事实上处于`TIME_WAIT`阶段的socket已经是半关闭的状态，将一个新的socket绑定在这个地址端口对上不会有任何问题。

# ****SO_KEEPALIVE****

关于SO_KEEPALIVE的含义是这样的：

- 如果通信两端超过2个小时没有交换数据，那么开启keep-alive的一端会自动发一个keep-alive包给对端。
- 如果对端正常的回应ACK包，那么一切都没问题，再等个2小时后发包(如果这两个小时仍然没有数据交换)。
- 如果对端回应RST包，表明对端程序崩溃或重启，这边socket产生ECONNRESET错误，并且关闭。
- 如果对端一直没回应，这边会每75秒再发包给对端，总共发8次共11分钟15秒。最后socket产生 ETIMEDOUT 错误，并且关闭。或者收到ICMP错误，表明主机不可到达，则会产生 EHOSTUNREACH 错误。

一般来说，如果应用层有心跳的话，TCP keepalive不是必须的

# TCP_NODELAY

开启或关闭Nagle算法

开启了Nagle算法，数据只有在写缓存中累积到一定量之后，才会被发送出去，这样明显提高了网络利用率（实际传输数据payload与协议头的比例大大提高）。但是这由不可避免地**增加了延时**

如果想要编写低延迟网络服务，可以选择关闭Nagle算法（它是默认开启的），允许小包的发送。